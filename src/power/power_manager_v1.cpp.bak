// =============================================================================
// POWER MANAGER - OPTIMIZED FOR T-WATCH S3
// =============================================================================
// Key optimizations:
// 1. Fast wake path (<100ms from touch to screen)
// 2. Proper CPU lock during recording/BLE transfers
// 3. Smooth state transitions with no display glitches
// 4. ESP-IDF automatic power management enabled
// =============================================================================

#include "power_manager.h"
#include "pmu.h"
#include "battery.h"
#include "../hardware_config.h"
#include "../ui/ui_common.h"
#include "../ui/ui_idle.h"
#include "../system/state.h"
#include "../audio/audio_i2s.h"
#include "../ble/ble_core.h"  // POWER: For BLE sleep mode control

#include <esp_pm.h>
#include <esp_sleep.h>
#include <esp_wifi.h>
#include <esp_bt.h>
#include <esp_bt_main.h>
#include <driver/rtc_io.h>
#include <driver/gpio.h>
#include <esp_system.h>
#include <soc/rtc.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>

// =============================================================================
// State Variables
// =============================================================================

PowerState g_powerState = POWER_ACTIVE;
volatile bool g_wokeFromSleep = false;
static uint32_t s_lastActivityMs = 0;
static uint32_t s_lightSleepEnteredMs = 0;
static bool s_pmConfigured = false;
static bool s_bleConnected = false;

// Wake timing metrics (for diagnostics)
static uint32_t s_lastWakeTimeUs = 0;
static uint32_t s_wakeCount = 0;
static uint32_t s_maxWakeTimeUs = 0;

// Light sleep lock - prevent sleep during critical operations
static esp_pm_lock_handle_t s_cpuLock = nullptr;
static bool s_cpuLockHeld = false;

// =============================================================================
// Internal: CPU Lock Management
// =============================================================================

static void acquireCpuLock() {
    if (s_cpuLock && !s_cpuLockHeld) {
        esp_pm_lock_acquire(s_cpuLock);
        s_cpuLockHeld = true;
    }
}

static void releaseCpuLock() {
    if (s_cpuLock && s_cpuLockHeld) {
        esp_pm_lock_release(s_cpuLock);
        s_cpuLockHeld = false;
    }
}

// =============================================================================
// Internal: Display Power Control
// =============================================================================

static void displaySetActive() {
    // POWER: Restore full CPU frequency for responsive UI
    setCpuFrequencyMhz(CPU_FREQ_MAX);
    pmuEnableDisplay();
    gfx.wakeup();
    gfx.setBrightness(g_isCharging ? BRIGHTNESS_CHARGING : BRIGHTNESS_ACTIVE);
}

static void displaySetDimmed() {
    // POWER: Reduce CPU frequency when dimmed (80MHz is enough for basic UI)
    setCpuFrequencyMhz(80);
    gfx.setBrightness(BRIGHTNESS_DIM);
}

static void displaySetOff() {
    // POWER: Optimized display shutdown sequence
    // 1. Turn off backlight FIRST (instant visual off)
    gfx.setBrightness(0);
    // 2. Put display controller into sleep mode (reduces display controller power)
    //    Skip fillScreen - it wastes power and display is already off visually
    gfx.sleep();
    // 3. Cut power to backlight circuit via PMU (ALDO2 off)
    pmuDisableDisplay();
}

// =============================================================================
// Internal: Configure ESP-IDF Power Management
// =============================================================================

static bool configurePowerManagement() {
    // ESP32-S3 power management configuration
    // This enables automatic light sleep when all tasks are idle

    esp_pm_config_esp32s3_t pm_config = {};
    pm_config.max_freq_mhz = CPU_FREQ_MAX;
    pm_config.min_freq_mhz = CPU_FREQ_MIN;
    pm_config.light_sleep_enable = true;

    esp_err_t err = esp_pm_configure(&pm_config);
    if (err != ESP_OK) {
        Serial.printf("[POWER] PM configure failed: %s\n", esp_err_to_name(err));
        return false;
    }

    // Create a CPU frequency lock for when we need guaranteed performance
    // (e.g., during audio recording or BLE transfers)
    err = esp_pm_lock_create(ESP_PM_CPU_FREQ_MAX, 0, "cpu_work", &s_cpuLock);
    if (err != ESP_OK) {
        Serial.printf("[POWER] Lock create failed: %s\n", esp_err_to_name(err));
        return false;
    }

    Serial.printf("[POWER] PM configured: %d-%dMHz, light_sleep=ON\n",
                  CPU_FREQ_MIN, CPU_FREQ_MAX);
    return true;
}

// =============================================================================
// Internal: Configure Wake Sources
// =============================================================================

static void configureWakeSources() {
    // Touch interrupt - GPIO 16, active LOW
    // Level-triggered wake for light sleep - fires when touch INT goes low
    gpio_wakeup_enable((gpio_num_t)TOUCH_INT_PIN, GPIO_INTR_LOW_LEVEL);
    esp_sleep_enable_gpio_wakeup();

    // PMU interrupt - GPIO 21, active LOW (power button, charger events)
    gpio_wakeup_enable((gpio_num_t)PMU_INT_PIN, GPIO_INTR_LOW_LEVEL);

    Serial.println("[POWER] Wake sources: GPIO16(touch), GPIO21(PMU)");
}

// =============================================================================
// Internal: Brownout Detection
// =============================================================================

static void checkBatteryHealth() {
    if (!g_pmuPresent) return;

    int voltage = g_pmu.getBattVoltage();

    if (voltage < SHUTDOWN_THRESHOLD_MV && !g_isCharging) {
        Serial.printf("[POWER] CRITICAL: Battery %dmV - forcing shutdown!\n", voltage);
        Serial.flush();

        // Give user visual feedback if possible
        gfx.fillScreen(TFT_RED);
        gfx.setTextColor(TFT_WHITE);
        gfx.setTextDatum(textdatum_t::middle_center);
        gfx.drawString("LOW BATTERY", SCREEN_W/2, SCREEN_H/2);
        delay(2000);

        // Shutdown via PMU (cleaner than brownout reset)
        g_pmu.shutdown();
    }
    else if (voltage < BROWNOUT_THRESHOLD_MV && !g_isCharging) {
        // Log warning but don't shutdown yet
        static uint32_t lastWarnMs = 0;
        if (millis() - lastWarnMs > 30000) {
            Serial.printf("[POWER] WARNING: Battery low %dmV\n", voltage);
            lastWarnMs = millis();
        }
    }
}

// =============================================================================
// Public: Initialization
// =============================================================================

bool powerManagerInit() {
    Serial.println("\n[POWER] Initializing power manager...");

    // 1. Ensure WiFi is completely disabled
    esp_err_t err = esp_wifi_stop();
    if (err == ESP_OK) {
        esp_wifi_deinit();
        Serial.println("[POWER] WiFi disabled");
    }

    // 2. Set initial CPU frequency
    setCpuFrequencyMhz(CPU_FREQ_MAX);
    Serial.printf("[POWER] CPU set to %dMHz\n", getCpuFrequencyMhz());

    // 3. Configure ESP-IDF power management for automatic light sleep
    s_pmConfigured = configurePowerManagement();
    if (!s_pmConfigured) {
        Serial.println("[POWER] WARNING: PM not configured - no auto light sleep!");
    }

    // 4. Configure wake sources
    configureWakeSources();

    // 5. Initialize timing
    s_lastActivityMs = millis();
    g_powerState = POWER_ACTIVE;

    Serial.println("[POWER] Power manager initialized\n");
    return s_pmConfigured;
}

// =============================================================================
// Public: Activity Tracking
// =============================================================================

void powerMarkActivity() {
    s_lastActivityMs = millis();

    // If we were in light sleep mode, set wake flag for main loop
    if (g_powerState == POWER_LIGHT_SLEEP) {
        g_wokeFromSleep = true;  // Main loop MUST call handleWakeFromLightSleep()
        // Don't transition here - handleWakeFromLightSleep() does full wake sequence
        return;
    }

    // From dimmed, just transition to active (no special handling needed)
    if (g_powerState == POWER_DIMMED) {
        g_powerState = POWER_ACTIVE;
        g_sleeping = false;
        g_dimmed = false;
        displaySetActive();
        s_lightSleepEnteredMs = 0;
        Serial.println("[POWER] -> ACTIVE (user activity)");
    }
}

void powerHandleBLEConnect() {
    s_bleConnected = true;
    powerMarkActivity();
    Serial.println("[POWER] BLE connected");
}

void powerHandleBLEDisconnect() {
    s_bleConnected = false;
    // Don't change power state - let normal timeout handle it
    Serial.println("[POWER] BLE disconnected");
}

// =============================================================================
// Public: State Machine Update
// =============================================================================

bool powerUpdate() {
    const uint32_t now = millis();
    const uint32_t idleMs = now - s_lastActivityMs;

    // Check battery health periodically
    static uint32_t lastBatteryCheck = 0;
    if (now - lastBatteryCheck > 10000) {
        lastBatteryCheck = now;
        checkBatteryHealth();
    }

    // Don't transition during recording
    if (g_recordingInProgress) {
        if (g_powerState != POWER_ACTIVE) {
            g_powerState = POWER_ACTIVE;
            g_sleeping = false;
            g_dimmed = false;
            displaySetActive();
            acquireCpuLock();  // Prevent auto light sleep during recording
        }
        return true;
    } else {
        releaseCpuLock();  // Allow auto light sleep
    }

    // Don't transition while charging (user might be watching)
    if (g_isCharging && g_powerState == POWER_LIGHT_SLEEP) {
        g_powerState = POWER_DIMMED;
        g_dimmed = true;
        g_sleeping = false;
        displaySetDimmed();
        return true;
    }

    // State machine
    switch (g_powerState) {
        case POWER_ACTIVE:
            if (idleMs >= TIMEOUT_DIM_MS) {
                g_powerState = POWER_DIMMED;
                g_dimmed = true;  // Sync legacy global
                g_sleeping = false;
                displaySetDimmed();
                Serial.println("[POWER] -> DIMMED");
            }
            break;

        case POWER_DIMMED:
            if (idleMs >= TIMEOUT_LIGHT_SLEEP_MS) {
                g_powerState = POWER_LIGHT_SLEEP;
                g_sleeping = true;  // Sync legacy global
                g_dimmed = false;
                displaySetOff();
                s_lightSleepEnteredMs = now;
                // POWER: Enter BLE sleep mode (slower polling, not disabled)
                bleEnterSleepMode();
                // POWER: Drop CPU to minimum during light sleep
                setCpuFrequencyMhz(CPU_FREQ_MIN);
                Serial.println("[POWER] -> LIGHT_SLEEP");
            }
            break;

        case POWER_LIGHT_SLEEP:
            // Check if we should go to deep sleep
            if (TIMEOUT_DEEP_SLEEP_MS > 0 && !g_isCharging && !s_bleConnected) {
                uint32_t lightSleepDuration = now - s_lightSleepEnteredMs;
                if (lightSleepDuration >= TIMEOUT_DEEP_SLEEP_MS) {
                    Serial.println("[POWER] -> DEEP_SLEEP");
                    powerForceDeepSleep();  // Does not return
                }
            }
            // In light sleep, ESP-IDF handles actual sleep automatically
            // We just need short delays in main loop
            break;

        case POWER_DEEP_SLEEP:
            // Should never be here - deep sleep triggers reset on wake
            break;
    }

    return true;
}

// =============================================================================
// Public: Force State Changes
// =============================================================================

void powerForceActive() {
    g_powerState = POWER_ACTIVE;
    g_sleeping = false;
    g_dimmed = false;
    s_lastActivityMs = millis();
    displaySetActive();
}

void powerForceLightSleep() {
    if (g_recordingInProgress) return;  // Safety check

    g_powerState = POWER_LIGHT_SLEEP;
    g_sleeping = true;
    g_dimmed = false;
    displaySetOff();
    s_lightSleepEnteredMs = millis();
}

void powerForceDeepSleep() {
    Serial.println("[POWER] Entering deep sleep...");
    Serial.flush();

    // 1. Stop all audio
    if (isMicRunning()) stopMic();
    deinitMic();

    // 2. Turn off display
    displaySetOff();

    // 3. Disable BLE completely for lowest power
    // BLE will reinitialize on wake (device does full reset from deep sleep)
    esp_bluedroid_disable();
    esp_bluedroid_deinit();
    esp_bt_controller_disable();
    esp_bt_controller_deinit();

    // 4. Prepare PMU - disable all non-essential rails
    pmuPrepareDeepSleep();

    // 5. Configure wake sources for deep sleep
    // EXT0: Touch (primary wake source, single GPIO, level-triggered LOW)
    esp_sleep_enable_ext0_wakeup((gpio_num_t)TOUCH_INT_PIN, 0);  // Wake on LOW

    // EXT1: PMU button as backup wake source (ALL_LOW means wake when this pin is LOW)
    // Note: This wakes when PMU INT goes low (power button pressed)
    esp_sleep_enable_ext1_wakeup(1ULL << PMU_INT_PIN, ESP_EXT1_WAKEUP_ALL_LOW);

    // 6. Isolate unused GPIO to prevent leakage
    rtc_gpio_isolate((gpio_num_t)MIC_DATA_PIN);
    rtc_gpio_isolate((gpio_num_t)MIC_CLK_PIN);
    rtc_gpio_isolate((gpio_num_t)I2S_BCK_PIN);
    rtc_gpio_isolate((gpio_num_t)I2S_WS_PIN);
    rtc_gpio_isolate((gpio_num_t)I2S_DOUT_PIN);

    Serial.println("[POWER] Deep sleep now - wake on touch/button/accel");
    Serial.flush();

    esp_deep_sleep_start();
    // Never returns - device resets on wake, BLE will reinit automatically
}

// =============================================================================
// Public: Wake Handler - MUST be called from main loop when g_wokeFromSleep is true
// =============================================================================
// CRITICAL: This function is optimized for SPEED. Target: <100ms wake time
// Every millisecond counts for user experience.
// =============================================================================

void handleWakeFromLightSleep() {
    uint32_t wakeStartUs = micros();

    // 1. Update power state FIRST (before any hardware access)
    //    This ensures other code sees the correct state immediately
    g_powerState = POWER_ACTIVE;
    g_sleeping = false;
    g_dimmed = false;
    s_lastActivityMs = millis();
    s_lightSleepEnteredMs = 0;

    // 2. Clear wake flag EARLY to prevent re-entry race conditions
    g_wokeFromSleep = false;

    // 3. POWER: Exit BLE sleep mode (restore faster polling)
    bleExitSleepMode();

    // 4. POWER: Restore CPU frequency FIRST (was dropped to minimum during sleep)
    setCpuFrequencyMhz(CPU_FREQ_MAX);

    // 5. Acquire CPU lock to prevent auto-sleep during wake sequence
    acquireCpuLock();

    // 6. Enable display power rail FIRST (PMU is fast, ~1ms)
    pmuEnableDisplay();

    // 7. Wake display controller - CRITICAL PATH
    gfx.wakeup();

    // 8. Set brightness BEFORE drawing to avoid flash
    gfx.setBrightness(g_isCharging ? BRIGHTNESS_CHARGING : BRIGHTNESS_ACTIVE);

    // 9. FORCE UI STATE TO HOME
    currentState = IDLE;
    lastDrawnState = IDLE;

    // 10. Draw HOME screen
    drawIdleScreen();

    // 11. Invalidate clock cache
    uiInvalidateClock();

    // 12. Mark wake tap consumed
    g_ignoreTap = true;

    // 13. Release CPU lock
    releaseCpuLock();

    // Track wake timing for diagnostics
    uint32_t wakeTimeUs = micros() - wakeStartUs;
    s_lastWakeTimeUs = wakeTimeUs;
    s_wakeCount++;
    if (wakeTimeUs > s_maxWakeTimeUs) {
        s_maxWakeTimeUs = wakeTimeUs;
    }

    Serial.printf("[POWER] WAKE #%lu: %lu us (%.1f ms) -> HOME%s\n",
                  s_wakeCount, wakeTimeUs, wakeTimeUs / 1000.0f,
                  (wakeTimeUs > WAKE_MAX_MS * 1000) ? " [SLOW!]" : "");
}

// =============================================================================
// Public: Query Functions
// =============================================================================

bool powerIsActive() {
    return g_powerState == POWER_ACTIVE;
}

bool powerIsDimmed() {
    return g_powerState == POWER_DIMMED;
}

bool powerIsLightSleep() {
    return g_powerState == POWER_LIGHT_SLEEP;
}

bool powerCanDoWork() {
    return g_powerState != POWER_DEEP_SLEEP;
}

uint32_t powerGetIdleTimeMs() {
    return millis() - s_lastActivityMs;
}

// =============================================================================
// Public: Diagnostics
// =============================================================================

void powerPrintDiagnostics() {
    Serial.println("\n========== POWER DIAGNOSTICS ==========");

    // CPU info
    Serial.printf("CPU Frequency: %d MHz (range: %d-%d)\n",
                  getCpuFrequencyMhz(), CPU_FREQ_MIN, CPU_FREQ_MAX);
    Serial.printf("Power State: %d ", g_powerState);
    switch(g_powerState) {
        case POWER_ACTIVE: Serial.println("(ACTIVE)"); break;
        case POWER_DIMMED: Serial.println("(DIMMED)"); break;
        case POWER_LIGHT_SLEEP: Serial.println("(LIGHT_SLEEP)"); break;
        case POWER_DEEP_SLEEP: Serial.println("(DEEP_SLEEP)"); break;
    }

    Serial.printf("Idle Time: %lu ms\n", powerGetIdleTimeMs());
    Serial.printf("BLE Connected: %s\n", s_bleConnected ? "YES" : "NO");
    Serial.printf("Recording: %s\n", g_recordingInProgress ? "YES" : "NO");
    Serial.printf("Charging: %s\n", g_isCharging ? "YES" : "NO");
    Serial.printf("PM Configured: %s\n", s_pmConfigured ? "YES" : "NO");
    Serial.printf("CPU Lock Held: %s\n", s_cpuLockHeld ? "YES" : "NO");

    // Wake timing stats
    Serial.println("\nWake Performance:");
    Serial.printf("  Wake Count: %lu\n", s_wakeCount);
    Serial.printf("  Last Wake: %.1f ms\n", s_lastWakeTimeUs / 1000.0f);
    Serial.printf("  Max Wake: %.1f ms\n", s_maxWakeTimeUs / 1000.0f);
    Serial.printf("  Target: <%lu ms\n", WAKE_TARGET_MS);

    // PMU rails
    if (g_pmuPresent) {
        Serial.println("\nPMU Power Rails:");
        Serial.printf("  ALDO1: %s\n", g_pmu.isEnableALDO1() ? "ON" : "off");
        Serial.printf("  ALDO2: %s (backlight)\n", g_pmu.isEnableALDO2() ? "ON" : "off");
        Serial.printf("  ALDO3: %s (display+touch)\n", g_pmu.isEnableALDO3() ? "ON" : "off");
        Serial.printf("  ALDO4: %s\n", g_pmu.isEnableALDO4() ? "ON" : "off");
        Serial.printf("  BLDO1: %s\n", g_pmu.isEnableBLDO1() ? "ON" : "off");
        Serial.printf("  BLDO2: %s (haptics)\n", g_pmu.isEnableBLDO2() ? "ON" : "off");
        Serial.printf("  DLDO1: %s (speaker)\n", g_pmu.isEnableDLDO1() ? "ON" : "off");
        Serial.printf("  DLDO2: %s\n", g_pmu.isEnableDLDO2() ? "ON" : "off");
        Serial.printf("  DC2: %s\n", g_pmu.isEnableDC2() ? "ON" : "off");
        Serial.printf("  DC3: %s (GPS)\n", g_pmu.isEnableDC3() ? "ON" : "off");
        Serial.printf("  DC4: %s\n", g_pmu.isEnableDC4() ? "ON" : "off");
        Serial.printf("  DC5: %s\n", g_pmu.isEnableDC5() ? "ON" : "off");

        Serial.println("\nBattery:");
        Serial.printf("  Voltage: %d mV\n", g_pmu.getBattVoltage());
        Serial.printf("  Percent: %d%%\n", g_pmu.getBatteryPercent());
        Serial.printf("  Charging: %s\n", g_pmu.isCharging() ? "YES" : "NO");
    }

    Serial.println("========================================\n");
}

float powerEstimateCurrentMa() {
    float current = 0.0f;

    // Base ESP32-S3 current at current frequency
    int freq = getCpuFrequencyMhz();
    if (freq >= 240) current += 50.0f;
    else if (freq >= 160) current += 35.0f;
    else if (freq >= 80) current += 25.0f;
    else current += 10.0f;

    // BLE adds significant current
    if (s_bleConnected) current += 15.0f;
    else current += 5.0f;  // Advertising

    // Display
    if (g_powerState == POWER_ACTIVE) current += 20.0f;
    else if (g_powerState == POWER_DIMMED) current += 5.0f;

    // Recording
    if (g_recordingInProgress) current += 10.0f;

    return current;
}
